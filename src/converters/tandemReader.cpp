#include "tandemReader.h"

static const XMLCh groupStr[] = { chLatin_g, chLatin_r, chLatin_o, chLatin_u, chLatin_p, chNull};
string schemaDefinition = TANDEM_SCHEMA_LOCATION + string("tandem2011.12.01.1.xsd");
string scheme_namespace = TANDEM_NAMESPACE;
string schema_major = "";
string schema_minor = "";

tandemReader::tandemReader(ParseOptions po):Reader(po)
{
  
}

tandemReader::~tandemReader()
{

}


//Some functions to handle strings
std::vector<std::string> &tandemReader::split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while(std::getline(ss, item, delim)) {
      if(item.find_first_of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_#@*?")!=std::string::npos){
	elems.push_back(item); 
      }
    }
    return elems;
}

std::vector<std::string>tandemReader::split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    return split(s, delim, elems);
}

//TODO fix this and add to interface
/**
xercesc::DOMElement* add_namespace (xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc,
               parser p,
               const XMLCh* ns)
{

  DOMElement* ne;
  DOMElement* e=doc->getDocumentElement();
  
  for (doc = p.next(); doc.get() != 0; doc = p.next ())
  {
    std::cerr << "Add: " << "1" << std::endl;
  }**/
  /**
  if(e.getNamespaceURI()!="http://www.bioml.com/gaml/")//Check if gaml namespace FIXME
  {
    ne =static_cast<DOMElement*> (doc->renameNode (e, ns, e->getLocalName ()));
  }else
  {
    ne=e;
  }

  ne =static_cast<DOMElement*> (doc->renameNode (e, ns, e->getLocalName ()));
  //static const XMLCH asdf=e->getLocalName;
  std::cerr << "Add: " << "1" << std::endl;
  
  for (DOMNode* n = ne->getFirstChild (); n != 0; n = n->getNextSibling ())
  {
    std::cerr << "Add: " << "2" << std::endl;
    if (n->getNodeType () == DOMNode::ELEMENT_NODE)
    {
      std::cerr << "Add: " << "3" << std::endl;
      n = add_namespace (doc,p,ns);
    }
  }**/

  //return ne;
//}

/**
xercesc::DOMElement* add_namespace (xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc,
               parser p,
               const std::string& ns)
{
  return add_namespace (doc, p, xsd::cxx::xml::string (ns).c_str ());
}**/


bool tandemReader::checkValidity(const std::string file)
{
  bool ismeta = true;
  std::ifstream fileIn(file.c_str(), std::ios::in);
  if (!fileIn) 
  {
    std::cerr << "Could not open file " << file << std::endl;
    exit(-1);
  }
  std::string line,line_xml,line_bioml;
  if (!getline(fileIn, line)) 
  {
    std::cerr << "Could not read file " << file << std::endl;
    exit(-1);
  }
  
  if (line.find("<?xml") != std::string::npos)
  {
    getline(fileIn, line_xml);
    getline(fileIn, line_bioml);
    
    if (line_xml.find("tandem") == std::string::npos||line_bioml.find("<bioml") == std::string::npos)
    {
      std::cerr << "XML file not generated by X!tandem: " << file << std::endl;
      exit(-1);
    }
    if(line_bioml.find("xmlns=\"http://www.thegpm.org/TANDEM/2011.12.01.1\"")!=std::string::npos){ 
      fixedXML=true;
    }else
    {
      fixedXML=false;
    }
  } 
  else
  {
    ismeta = false;
  }

  fileIn.close();
  return ismeta;
}


void  tandemReader::addFeatureDescriptions(bool doEnzyme,const std::string& aaAlphabet,std::string fn) //TODO Needs some changes
{
  push_backFeatureDescription("deNovoScore");
  push_backFeatureDescription("MSGFScore");
  push_backFeatureDescription("Mass");
  push_backFeatureDescription("PepLen");
  
  for (int charge = minCharge; charge <= maxCharge; ++charge) 
  {
    std::ostringstream cname;
    cname << "Charge" << charge;
    push_backFeatureDescription(cname.str().c_str());

  }
  if (doEnzyme) 
  {
    push_backFeatureDescription("enzN");
    push_backFeatureDescription("enzC");
    push_backFeatureDescription("enzInt");
  }
  
  //Mass difference
  push_backFeatureDescription("dM");
  push_backFeatureDescription("absdM");
  
  if (po.calcPTMs) 
  {
    push_backFeatureDescription("ptm");
  }
  
  if (po.pngasef) 
  {
    push_backFeatureDescription("PNGaseF");
  }
  
  if (po.calcAAFrequencies)
  {
    for (std::string::const_iterator it = aaAlphabet.begin(); it != aaAlphabet.end(); it++)
    {
      std::string temp = boost::lexical_cast<std::string>(*it)+"-Freq";
      push_backFeatureDescription(temp.c_str());
    }
  }
}

void tandemReader::getMaxMinCharge(const std::string fn){
  
  int nTot = 0, charge = 0;
  
  namespace xml = xsd::cxx::xml;
 
  ifstream ifs;
  ifs.exceptions(ifstream::badbit|ifstream::failbit);
    
  ifs.open(fn.c_str());
  parser p;
  
  try
  {
    xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc (p.start (ifs, fn.c_str(),true, schemaDefinition,schema_major, schema_minor, scheme_namespace));
    assert(doc.get());
    
    for (doc = p.next(); doc.get() != 0; doc = p.next ())
    {
      if(!fixedXML) //Fix xml and parse to object model TODO
      {
	std::cerr << "Fixing xml file" << std::endl; //TMP
	//add_namespace (doc,"http://www.thegpm.org/TANDEM/2011.12.01.1");
      }
      
      try{
	tandem_ns::group groupObj(*doc->getDocumentElement());
	if(XMLString::equals(groupStr,doc->getDocumentElement()->getTagName()) && groupObj.type()!="parameters") //Check that the tag name is group and that its not the inputput parameters
	{
	  if(groupObj.z().present()) //We are sure we are not in parameters group so z(the charge) has to be present.
	  {
	    stringstream chargeStream (stringstream::in | stringstream::out);
	    chargeStream << groupObj.z();
	    if (minCharge > charge) minCharge = charge;
	    if (maxCharge < charge) maxCharge = charge;
	    nTot++;
	  }else
	  {
	    cerr << "Missing charge(attribute z in group element) for one or more groups in: " << fn << endl;
	    exit(1);
	  }
	}
      }catch(exception e)
      {
	cerr << "Problem parsing the codesynthesis object model for the xml file: " << fn << endl;
	cerr << e.what() << endl;
	exit(1);
      }
    }
  }catch (const xml_schema::exception& e)
  {
    cerr << "Problem reading the xml file: " << fn << endl;
    cerr << e << endl;
    exit(1);
  }
  
  if(nTot<=0)
  {
    std::cerr << "The file " << fn << " does not contain any records" << std::endl;
    exit(1);
  }
   
  ifs.close();
  return;
}

/**
void tandemReader::readPSM(std::string line,bool isDecoy,std::string fileId,
			   boost::shared_ptr<FragSpectrumScanDatabase> database, std::vector<std::string> column_names){
  
  
}**/

void tandemReader::read(const std::string fn, bool isDecoy,boost::shared_ptr<FragSpectrumScanDatabase> database)
{
  std::string line, tmp, prot, fileId;
  std::istringstream lineParse;
  std::ifstream tandemIn;
  
  namespace xml = xsd::cxx::xml;
  
  fileId = fn;
  size_t spos = fileId.rfind('/');
  if (spos != std::string::npos) fileId.erase(0, spos + 1);
  spos = fileId.find('.');
  if (spos != std::string::npos) fileId.erase(spos);
  
  ifstream ifs;
  ifs.exceptions(ifstream::badbit|ifstream::failbit);
    
  ifs.open(fn.c_str());
  parser p;
    
  try //TODO move the try catch
  {     
    xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc (p.start (ifs, fn.c_str(),true, schemaDefinition,schema_major, schema_minor, scheme_namespace));
    
    assert(doc.get());
    
    //tandem_ns::bioml biomlObj=biomlObj(*doc->getDocumentElement());
    //std::cerr << "Bioml label: " << biomlObj.label() << std::endl;
    
    for (doc = p.next(); doc.get() != 0; doc = p.next ())
    {
      
      
      //xml_schema::dom::auto_ptr< xercesc::DOMDocument> docGroup=xercesc_3_1::DOMImplementation::createDocument();
     
      //xml_schema::dom::auto_ptr< xercesc::DOMDocument> docGroup=NULL;
      
      //docGroup.adoptNode(*doc->getDocumentElement(),true);
      
      //docGroup.setUserData (xml_schema::dom::tree_node_key, docGroup.get (), 0);
     
      //tandem_ns::group groupObj(*docGroup->getDocumentElement(),xml_schema::flags::dont_validate | xml_schema::flags::keep_dom | xml_schema::flags::dont_initialize);
      
      // The caller should have associated a dom::auto_ptr object
      // that owns this document with the document node using the
      // xml_schema::dom::tree_node_key key.
      
      
      //TODO Add namespace if missing here
      if(!fixedXML)
      {
	//Fix xml and parse to object model
	std::cerr << "Fixing xml file" << std::endl; //TMP
	//add_namespace (doc,"http://www.thegpm.org/TANDEM/2011.12.01.1");
      }
      
      try
      {
	tandem_ns::group groupObj(*doc->getDocumentElement());
	if(XMLString::equals(groupStr,doc->getDocumentElement()->getTagName()) && groupObj.type()!="parameters") //Check that the tag name is group and that its not the inputput parameters
	{

	  BOOST_FOREACH(const tandem_ns::group::protein_type &protObj, groupObj.protein()) //Protein
	  {
	    tandem_ns::protein::peptide_type peptideObj=protObj.peptide();
	    tandem_ns::peptide::domain_type domainObj=peptideObj.domain();

	  }
	
	  BOOST_FOREACH(const tandem_ns::group::group1_type &groupGAMLObj, groupObj.group1()) //Getting the group element surrounding the GAML namespace
	  {
	  
	    BOOST_FOREACH(const gaml_tandem_ns::trace &traceGAMLObj, groupGAMLObj.trace()) //GAML:trace
	    {
	      
	      BOOST_FOREACH(const gaml_tandem_ns::attribute &attributeTraceGAMLObj, traceGAMLObj.attribute()) //GAML:attribute
	      {
		gaml_tandem_ns::attribute::type_type typeAttr=attributeTraceGAMLObj.type();
		if(typeAttr=="a0") //ao value, related to the hyperscore expectation
		{
		  cerr << "a0" << std::endl;
		} else if(typeAttr=="a1") //a1 value, related to the hyperscore expectation
		{
		  cerr << "a1" << std::endl;
		}
	      }
	    }
	  }
	}
      }catch(exception e)
      {
	cerr << "Problem parsing the codesynthesis object model for the xml file: " << fn << endl;
	cerr << e.what() << endl;
	exit(1);
      } 
      //*docGroup.release(); //Remove it and its children
    }
    
    ifs.close();
    
    // XMLString Transcode get text content
  }
  catch (const xml_schema::exception& e)
  {
    cerr << "Problem reading the xml file: " << fn << endl;
    cerr << e << endl;
    exit(1);
  }
  
}

