#include "tandemReader.h"

tandemReader::tandemReader(ParseOptions po):Reader(po)
{
  
}

tandemReader::~tandemReader()
{

}


//Some functions to handle strings
std::vector<std::string> &tandemReader::split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while(std::getline(ss, item, delim)) {
      if(item.find_first_of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_#@*?")!=std::string::npos){
	elems.push_back(item); 
      }
    }
    return elems;
}

std::vector<std::string>tandemReader::split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    return split(s, delim, elems);
}


bool tandemReader::checkValidity(const std::string file)
{
  bool ismeta = true;
  std::ifstream fileIn(file.c_str(), std::ios::in);
  if (!fileIn) 
  {
    std::cerr << "Could not open file " << file << std::endl;
    exit(-1);
  }
  std::string line,line_xml,line_bioml;
  if (!getline(fileIn, line)) 
  {
    std::cerr << "Could not read file " << file << std::endl;
    exit(-1);
  }
  
  if (line.find("<?xml") != std::string::npos)
  {
    getline(fileIn, line_xml);
    getline(fileIn, line_bioml);
    
    if (line_xml.find("tandem") == std::string::npos||line_bioml.find("<bioml") == std::string::npos)
    {
      std::cerr << "XML file not generated by X!tandem: " << file << std::endl;
      exit(-1);
    }
  } 
  else
  {
    ismeta = false;
  }

  fileIn.close();
  return ismeta;
}


void  tandemReader::addFeatureDescriptions(bool doEnzyme,const std::string& aaAlphabet,std::string fn) //TODO Needs some changes
{
  push_backFeatureDescription("deNovoScore");
  push_backFeatureDescription("MSGFScore");
  push_backFeatureDescription("Mass");
  push_backFeatureDescription("PepLen");
  
  for (int charge = minCharge; charge <= maxCharge; ++charge) 
  {
    std::ostringstream cname;
    cname << "Charge" << charge;
    push_backFeatureDescription(cname.str().c_str());

  }
  if (doEnzyme) 
  {
    push_backFeatureDescription("enzN");
    push_backFeatureDescription("enzC");
    push_backFeatureDescription("enzInt");
  }
  
  //Mass difference
  push_backFeatureDescription("dM");
  push_backFeatureDescription("absdM");
  
  if (po.calcPTMs) 
  {
    push_backFeatureDescription("ptm");
  }
  
  if (po.pngasef) 
  {
    push_backFeatureDescription("PNGaseF");
  }
  
  if (po.calcAAFrequencies)
  {
    for (std::string::const_iterator it = aaAlphabet.begin(); it != aaAlphabet.end(); it++)
    {
      std::string temp = boost::lexical_cast<std::string>(*it)+"-Freq";
      push_backFeatureDescription(temp.c_str());
    }
  }
}

void tandemReader::getMaxMinCharge(const std::string fn){ //TODO Fix this
  
  int n = 0, charge = 0;
  
  std::string line, tmp, prot;
  std::istringstream lineParse;
  std::ifstream tandemIn;
  tandemIn.open(fn.c_str(), std::ios::in);
  if (!tandemIn) {
    std::cerr << "Could not open file " << fn << std::endl;
    exit(-1);
  }


  minCharge = 1;
  maxCharge = 4;

  tandemIn.close();
  return;
}

/**
void tandemReader::readPSM(std::string line,bool isDecoy,std::string fileId,
			   boost::shared_ptr<FragSpectrumScanDatabase> database, std::vector<std::string> column_names){
  
  std::ostringstream id;
  std::vector< std::string > proteinIds;
  std::vector< std::string > proteinIdsDecoys; //This vector is only used when we read a combined file
  bool tda1=false;
  
  std::auto_ptr< percolatorInNs::features >  features_p( new percolatorInNs::features ());
  percolatorInNs::features::feature_sequence & f_seq =  features_p->feature();
  std::map<char,int> ptmMap = po.ptmScheme;
  
  std::vector<std::string> psm_vector=split(line,'\t');
  if(psm_vector.size()!=column_names.size())
  {
    std::cerr << "One row or more in " << fileId << " has the wrong number of columns: "<< psm_vector.size() << ". Should be " << column_names.size() << std::endl;
    exit(-1);
  }
  if(column_names.at(13)=="FDR"){//If this is true then the -tda 1 option was used in msgfb
    tda1=true;
  }
  
  //Variables related to the MSGFDB file type 
  std::string specFile=boost::lexical_cast<std::string>(psm_vector.at(0));
  double specIndex=boost::lexical_cast<double>(psm_vector.at(1));
  double scan=boost::lexical_cast<double>(psm_vector.at(2));
  std::string fragMethod=boost::lexical_cast<std::string>(psm_vector.at(3));
  double observedMassCharge=boost::lexical_cast<double>(psm_vector.at(4)); //Called precursor mass in the msgfdb file
  double pmError=boost::lexical_cast<double>(psm_vector.at(5));
  int charge=boost::lexical_cast<int>(psm_vector.at(6));
  std::string peptide=boost::lexical_cast<std::string>(psm_vector.at(7));
  std::string proteinID=boost::lexical_cast<std::string>(psm_vector.at(8));
  double deNovoScore=boost::lexical_cast<double>(psm_vector.at(9));
  double MSGFScore=boost::lexical_cast<double>(psm_vector.at(10));
  double specProb=boost::lexical_cast<double>(psm_vector.at(11));
  double pValue=boost::lexical_cast<double>(psm_vector.at(12));
  
  double EFDR; 	//Used if tda1 option was used
  double PepFDR;//Used if tda1 option was used
  double FDR; 	//Used if tda1 option was not used in msgfb
  
  if(tda1){//if -tda 1 option is was used in msgfdb there is one more feature and FDR is sligtly different
    EFDR=boost::lexical_cast<double>(psm_vector.at(13));
    PepFDR=boost::lexical_cast<double>(psm_vector.at(14));
  }else
  {
    FDR=atof(psm_vector.at(13).c_str()); //NOTE lexical_cast not working
    //FDR=boost::lexical_cast<double>(psm_vector.at(13));
  }
  
  //std::cerr << "1 " << observedMassCharge << "\t" << pmError << "\t" << deNovoScore << "\t" << MSGFScore << "\t" << specProb << "\t" << pValue << "\t" << FDR << std::endl;
  //std::cerr << "2 " << psm_vector.at(4) << "\t" << psm_vector.at(5) << "\t" << psm_vector.at(9) << "\t" << psm_vector.at(10) << "\t" << psm_vector.at(11) << "\t" << psm_vector.at(12) << "\t" << psm_vector.at(13) << std::endl;
   
  //Create id
  id.str("");
  id << fileId << '_' << specIndex << '_' << scan;
  std::string psmId=id.str();
  
  //Get rid of unprinatables in proteinID and make list of proteinIDs
  proteinID=getRidOfUnprintables(proteinID);
  if(po.iscombined){
    if( (line.find(po.reversedFeaturePattern) != std::string::npos) )
      proteinIdsDecoys.push_back(proteinID);
    else
      proteinIds.push_back(proteinID);
  }
  else{
    proteinIds.push_back(proteinID);
  }
  
  //Check length of peptide, if its to short it cant contain both flanks and peptide
  assert(peptide.size() >= 5 );
  
  //Calculate peptide mass
  double calculatedMassToCharge=Reader::calculatePepMAss(peptide,charge);
  
  //Push_back the DeNovoScore and msgfscore
  f_seq.push_back(deNovoScore);
  f_seq.push_back(MSGFScore);

  f_seq.push_back( observedMassCharge ); // Observed mass
  f_seq.push_back( peptideLength(peptide)); // Peptide length
  int nxtFeat = 8;
  for (int c = minCharge; c
  <= maxCharge; c++)
    f_seq.push_back( charge == c ? 1.0 : 0.0); // Charge

  if (Enzyme::getEnzymeType() != Enzyme::NO_ENZYME) {
    f_seq.push_back( Enzyme::isEnzymatic(peptide.at(0),peptide.at(2)) ? 1.0 : 0.0);
    f_seq.push_back(Enzyme::isEnzymatic(peptide.at(peptide.size() - 3),peptide.at(peptide.size() - 1)) ? 1.0 : 0.0);
    std::string peptid2 = peptide.substr(2, peptide.length() - 4);
    f_seq.push_back( (double)Enzyme::countEnzymatic(peptid2) );
  }
  
  //Calculate difference between observed and calculated mass
  double dM =MassHandler::massDiff(observedMassCharge, calculatedMassToCharge,
                                   charge, peptide.substr(2, peptide.size()- 4));
  f_seq.push_back( dM ); // obs - calc mass
  f_seq.push_back( (dM < 0 ? -dM : dM)); // abs only defined for integers on some systems
  
  if (po.calcPTMs) 
  {
    f_seq.push_back(cntPTMs(peptide));
  }
  if (po.pngasef) 
  {
    f_seq.push_back(isPngasef(peptide,isDecoy));
  }
  if (po.calcAAFrequencies) {
    computeAAFrequencies(peptide, f_seq);
  }
  
  //Get the flanks/termini and remove them from the peptide sequence
  std::vector<std::string> tmp_vect=split(peptide,'.');
  percolatorInNs::occurence::flankN_type flankN;
  percolatorInNs::occurence::flankC_type flankC;
  std::string peptideSequence;
  std::string peptideS;
  
  try{
    flankN=tmp_vect.at(0);
    flankC=tmp_vect.at(2); 

    peptideSequence=tmp_vect.at(1);
    peptideS = peptideSequence;
  }
  catch(exception e){
    std::cerr << "There is a problem with the peptide string: " << peptide << " SpecIndex: " << specIndex << std::endl;
    exit(-1);
  }
  
  //Remove modifications
  for(unsigned int ix=0;ix<peptideSequence.size();++ix) {
    if (aaAlphabet.find(peptideSequence[ix])==string::npos && ambiguousAA.find(peptideSequence[ix])==string::npos
	&& modifiedAA.find(peptideSequence[ix])==string::npos){
      if (ptmMap.count(peptideSequence[ix])==0) {
	cerr << "Peptide sequence " << peptide << " contains modification " << peptideSequence[ix] << " that is not specified by a \"-p\" argument" << endl;
        exit(-1);
      }
      peptideSequence.erase(ix,1);
    }  
  }
  std::auto_ptr< percolatorInNs::peptideType >  peptide_p( new percolatorInNs::peptideType( peptideSequence   ) );
  
  //Register the ptms
  for(unsigned int ix=0;ix<peptideS.size();++ix) {
    if (aaAlphabet.find(peptideS[ix])==string::npos) {
      int accession = ptmMap[peptideS[ix]];
      std::auto_ptr< percolatorInNs::uniMod > um_p (new percolatorInNs::uniMod(accession));
      std::auto_ptr< percolatorInNs::modificationType >  mod_p( new percolatorInNs::modificationType(um_p,ix));
      peptide_p->modification().push_back(mod_p);      
      peptideS.erase(ix,1);      
    }  
  }
  
  if(po.iscombined)
  {
    //NOTE when combine search the PSM will take the identity of its first ranked Peptide
    isDecoy = proteinIds.front().find(po.reversedFeaturePattern, 0) != std::string::npos;
  }
  
  percolatorInNs::peptideSpectrumMatch* tmp_psm = new percolatorInNs::peptideSpectrumMatch (
	features_p,  peptide_p,psmId, isDecoy, observedMassCharge, calculatedMassToCharge, charge);
  std::auto_ptr< percolatorInNs::peptideSpectrumMatch >  psm_p(tmp_psm);

  for ( std::vector< std::string >::const_iterator i = proteinIds.begin(); i != proteinIds.end(); ++i ) 
  {
    std::auto_ptr< percolatorInNs::occurence >  oc_p( new percolatorInNs::occurence (*i,flankN, flankC)  );
    psm_p->occurence().push_back(oc_p);
  }
  
  database->savePsm(scan, psm_p);
}**/

void tandemReader::read(const std::string fn, bool isDecoy,boost::shared_ptr<FragSpectrumScanDatabase> database)
{
  std::string line, tmp, prot, fileId;
  std::istringstream lineParse;
  std::ifstream tandemIn;
  tandemIn.open(fn.c_str(), std::ios::in);
  if (!tandemIn) {
    std::cerr << "Could not open file " << fn << std::endl;
    exit(-1);
  }
  
  //The first row contains the names of the columns
  getline(tandemIn, line);
  std::vector<std::string> column_names=split(line,'\t');
  
  if(column_names.at(0)[0]=='#'){
    column_names.at(0)=column_names.at(0).erase(0,1); //Remove "#" in the first name
  }
  
  fileId = fn;
  size_t spos = fileId.rfind('/');
  if (spos != std::string::npos) fileId.erase(0, spos + 1);
  spos = fileId.find('.');
  if (spos != std::string::npos) fileId.erase(spos);
  
  //TODO read file here
  
  namespace xml = xsd::cxx::xml;
  
  
  //NOTE in tandem.xml  added xmlns="http://www.thegpm.org/TANDEM/2011.12.01.1"
  
  try
  {  
    ifstream ifs;
    ifs.exceptions(ifstream::badbit|ifstream::failbit);
    
    ifs.open(fn.c_str());
    parser p;
    
    string schemaDefinition = TANDEM_SCHEMA_LOCATION + string("tandem2011.12.01.1.xsd");
    string scheme_namespace = TANDEM_NAMESPACE;
    
    //string schemaDefinition = string("tandem.xsd");
    //string scheme_namespace = "tandem";
    
    string schema_major = "";
    string schema_minor = "";
    xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc (p.start (ifs, fn.c_str(),true, schemaDefinition,schema_major, schema_minor, scheme_namespace));

    //auto_ptr<bioml> bioml_p (new bioml (doc->next()));

    std::cerr << "TMP1 " << std::endl;
    for (doc = p.next(); doc.get() != 0; doc = p.next ()) 
    {
      std::cerr << "TMP iter " << std::endl;
      cerr << *doc->getDocumentElement()->getTagName() << std::endl;
    }

    ifs.close();

    /*for (bioml::group_const_iterator i (bioml_p->group ().begin ());
         i != bioml_p->group ().end ();
         ++i)
    {*/
	//i är pekare på group och *i är värdet

	//cout << "Id: " << i->id() << endl;

    	/*for (group_t::name_const_iterator j (i->name ().begin ());
             j != i->name ().end ();
            ++j)
    	{
      		cout << i->greeting () << ", " << *j << "!" << endl;
    	}*/
    //}
  }
  catch (const xml_schema::exception& e)
  {
    cerr << "Problem with xml file and xercesc and/or codesynthesis:" << endl;
    cerr << e << endl;
    exit(1);
  }
  
  std::cerr << "TMP Done reader " << std::endl;
}

