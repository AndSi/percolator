#include "tandemReader.h"

static const XMLCh groupStr[] = { chLatin_g, chLatin_r, chLatin_o, chLatin_u, chLatin_p, chNull};
string schemaDefinition = TANDEM_SCHEMA_LOCATION + string("tandem2011.12.01.1.xsd");
string scheme_namespace = TANDEM_NAMESPACE;
string schema_major = "";
string schema_minor = "";

tandemReader::tandemReader(ParseOptions po):Reader(po)
{
  
}

tandemReader::~tandemReader()
{

}


//Some functions to handle strings
std::vector<std::string> &tandemReader::split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while(std::getline(ss, item, delim)) {
      if(item.find_first_of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_#@*?")!=std::string::npos){
	elems.push_back(item); 
      }
    }
    return elems;
}

std::vector<std::string>tandemReader::split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    return split(s, delim, elems);
}

//TODO fix this and add to interface
/**
xercesc::DOMElement* add_namespace (xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc,
               parser p,
               const XMLCh* ns)
{

  DOMElement* ne;
  DOMElement* e=doc->getDocumentElement();
  
  for (doc = p.next(); doc.get() != 0; doc = p.next ())
  {
    std::cerr << "Add: " << "1" << std::endl;
  }**/
  /**
  if(e.getNamespaceURI()!="http://www.bioml.com/gaml/")//Check if gaml namespace FIXME
  {
    ne =static_cast<DOMElement*> (doc->renameNode (e, ns, e->getLocalName ()));
  }else
  {
    ne=e;
  }

  ne =static_cast<DOMElement*> (doc->renameNode (e, ns, e->getLocalName ()));
  //static const XMLCH asdf=e->getLocalName;
  std::cerr << "Add: " << "1" << std::endl;
  
  for (DOMNode* n = ne->getFirstChild (); n != 0; n = n->getNextSibling ())
  {
    std::cerr << "Add: " << "2" << std::endl;
    if (n->getNodeType () == DOMNode::ELEMENT_NODE)
    {
      std::cerr << "Add: " << "3" << std::endl;
      n = add_namespace (doc,p,ns);
    }
  }**/

  //return ne;
//}

/**
xercesc::DOMElement* add_namespace (xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc,
               parser p,
               const std::string& ns)
{
  return add_namespace (doc, p, xsd::cxx::xml::string (ns).c_str ());
}**/


bool tandemReader::checkValidity(const std::string file)
{
  bool ismeta = true;
  std::ifstream fileIn(file.c_str(), std::ios::in);
  if (!fileIn) 
  {
    std::cerr << "Could not open file " << file << std::endl;
    exit(-1);
  }
  std::string line,line_xml,line_bioml;
  if (!getline(fileIn, line)) 
  {
    std::cerr << "Could not read file " << file << std::endl;
    exit(-1);
  }
  
  if (line.find("<?xml") != std::string::npos)
  {
    getline(fileIn, line_xml);
    getline(fileIn, line_bioml);
    
    if (line_xml.find("tandem") == std::string::npos||line_bioml.find("<bioml") == std::string::npos)
    {
      std::cerr << "XML file not generated by X!tandem: " << file << std::endl;
      exit(-1);
    }
    if(line_bioml.find("xmlns=\"http://www.thegpm.org/TANDEM/2011.12.01.1\"")!=std::string::npos){ 
      fixedXML=true;
    }else
    {
      fixedXML=false;
    }
  } 
  else
  {
    ismeta = false;
  }

  fileIn.close();
  return ismeta;
}


void  tandemReader::addFeatureDescriptions(bool doEnzyme,const std::string& aaAlphabet,std::string fn) //TODO Needs some changes
{
  push_backFeatureDescription("deNovoScore");
  push_backFeatureDescription("MSGFScore");
  push_backFeatureDescription("Mass");
  push_backFeatureDescription("PepLen");
  
  for (int charge = minCharge; charge <= maxCharge; ++charge) 
  {
    std::ostringstream cname;
    cname << "Charge" << charge;
    push_backFeatureDescription(cname.str().c_str());

  }
  if (doEnzyme) 
  {
    push_backFeatureDescription("enzN");
    push_backFeatureDescription("enzC");
    push_backFeatureDescription("enzInt");
  }
  
  //Mass difference
  push_backFeatureDescription("dM");
  push_backFeatureDescription("absdM");
  
  if (po.calcPTMs) 
  {
    push_backFeatureDescription("ptm");
  }
  
  if (po.pngasef) 
  {
    push_backFeatureDescription("PNGaseF");
  }
  
  if (po.calcAAFrequencies)
  {
    for (std::string::const_iterator it = aaAlphabet.begin(); it != aaAlphabet.end(); it++)
    {
      std::string temp = boost::lexical_cast<std::string>(*it)+"-Freq";
      push_backFeatureDescription(temp.c_str());
    }
  }
}

void tandemReader::getMaxMinCharge(const std::string fn){
  
  int nTot = 0, charge = 0;
  
  namespace xml = xsd::cxx::xml;
 
  ifstream ifs;
  ifs.exceptions(ifstream::badbit|ifstream::failbit);
    
  ifs.open(fn.c_str());
  parser p;
  
  try
  {
  xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc (p.start (ifs, fn.c_str(),true, schemaDefinition,schema_major, schema_minor, scheme_namespace));
  assert(doc.get());
    
  for (doc = p.next(); doc.get() != 0; doc = p.next ())
  {
    if(!fixedXML) //Fix xml and parse to object model TODO
    {
      std::cerr << "Fixing xml file" << std::endl; //TMP
      //add_namespace (doc,"http://www.thegpm.org/TANDEM/2011.12.01.1");
    }
      
    if(XMLString::equals(groupStr,doc->getDocumentElement()->getTagName()))
    {
      try{
	tandem_ns::group groupObj(*doc->getDocumentElement());
	
	BOOST_FOREACH(const tandem_ns::group::group1_type &groupGAML, groupObj.group1()) //Getting the group element surrounding the GAML namespace
	{
	  
	  BOOST_FOREACH(const gaml_tandem_ns::trace &traceGAML, groupGAML.trace()) //GAML:trace
	  {
	    if(traceGAML.type()=="tandem mass spectrum")//Check that were are looking at the right trace element
	    {
	      BOOST_FOREACH(const gaml_tandem_ns::attribute &attributeTraceGAML, traceGAML.attribute()) //GAML:attribute
	      {
	      
		gaml_tandem_ns::attribute::type_type typeAttr=attributeTraceGAML.type();
		if(typeAttr=="charge")//Not all attribute elements are for charge
		{
		  //std::string chargeStr=
		  //charge=boost::lexical_cast<int>(chargeStr);
		  if (minCharge > charge) minCharge = charge;
		  if (maxCharge < charge) maxCharge = charge;
		  nTot++;
		}
	      }
	    }
	  }
	  
	}
      }catch(exception e)
      {
	cerr << "Problem parsing the codesynthesis object model for the xml file: " << fn << endl;
	cerr << e.what() << endl;
	exit(1);
      }
	
    }
      
  }
  }catch (const xml_schema::exception& e)
  {
    cerr << "Problem reading the xml file: " << fn << endl;
    cerr << e << endl;
    exit(1);
  }
  
  if(nTot<=0)
  {
    std::cerr << "The file " << fn << " does not contain any records" << std::endl;
    exit(1);
  }
   
  ifs.close();
  return;
}

/**
void tandemReader::readPSM(std::string line,bool isDecoy,std::string fileId,
			   boost::shared_ptr<FragSpectrumScanDatabase> database, std::vector<std::string> column_names){
  
  
}**/

void tandemReader::read(const std::string fn, bool isDecoy,boost::shared_ptr<FragSpectrumScanDatabase> database)
{
  std::string line, tmp, prot, fileId;
  std::istringstream lineParse;
  std::ifstream tandemIn;
  tandemIn.open(fn.c_str(), std::ios::in);
  if (!tandemIn) {
    std::cerr << "Could not open file " << fn << std::endl;
    exit(-1);
  }
  
  //The first row contains the names of the columns
  getline(tandemIn, line);
  std::vector<std::string> column_names=split(line,'\t');
  
  if(column_names.at(0)[0]=='#'){
    column_names.at(0)=column_names.at(0).erase(0,1); //Remove "#" in the first name
  }
  
  fileId = fn;
  size_t spos = fileId.rfind('/');
  if (spos != std::string::npos) fileId.erase(0, spos + 1);
  spos = fileId.find('.');
  if (spos != std::string::npos) fileId.erase(spos);
  
  //TODO max hits per spectra
  
  namespace xml = xsd::cxx::xml;
  
  
  //NOTE in tandem.xml  added xmlns="http://www.thegpm.org/TANDEM/2011.12.01.1"
  
  try //TODO move the try catch
  {  
    ifstream ifs;
    ifs.exceptions(ifstream::badbit|ifstream::failbit);
    
    ifs.open(fn.c_str());
    parser p;
    
    xml_schema::dom::auto_ptr< xercesc::DOMDocument> doc (p.start (ifs, fn.c_str(),true, schemaDefinition,schema_major, schema_minor, scheme_namespace));
    
    assert(doc.get());
    
    //tandem_ns::bioml biomlObj=biomlObj(*doc->getDocumentElement());
    //std::cerr << "Bioml label: " << biomlObj.label() << std::endl; //TMP
    
    for (doc = p.next(); doc.get() != 0; doc = p.next ())
    {
      
      
      //xml_schema::dom::auto_ptr< xercesc::DOMDocument> docGroup=xercesc_3_1::DOMImplementation::createDocument();
     
      //xml_schema::dom::auto_ptr< xercesc::DOMDocument> docGroup=NULL;
      
      //docGroup.adoptNode(*doc->getDocumentElement(),true);
      
      //docGroup.setUserData (xml_schema::dom::tree_node_key, docGroup.get (), 0);
     
      //tandem_ns::group groupObj(*docGroup->getDocumentElement(),xml_schema::flags::dont_validate | xml_schema::flags::keep_dom | xml_schema::flags::dont_initialize);
      
      
      // The caller should have associated a dom::auto_ptr object
      // that owns this document with the document node using the
      // xml_schema::dom::tree_node_key key.
      
      
      //TODO Add namespace if missing here
      if(!fixedXML)
      {
	//Fix xml and parse to object model
	std::cerr << "Fixing xml file" << std::endl; //TMP
	//add_namespace (doc,"http://www.thegpm.org/TANDEM/2011.12.01.1");
      } 
      
      tandem_ns::group groupObj(*doc->getDocumentElement());
      
      //std::cerr << "Type: " << groupObj.type() << std::endl; //TMP
      
      if(XMLString::equals(groupStr,doc->getDocumentElement()->getTagName()) && groupObj.type()!="parameters") //Check that the tag name is group and that its not the inputput parameters
      {
	std::cerr << "Id group: " << groupObj.id() << std::endl;
	tandem_ns::group::protein_sequence protObj=groupObj.protein();

	BOOST_FOREACH(const tandem_ns::group::protein_type &prot, groupObj.protein())
	{
	  tandem_ns::protein::peptide_type peptideObj=prot.peptide();
	  //std::cerr << "Pep: " << peptideObj << std::endl;
	  
	  
	  if (prot.note().present())       // test
	  {
	    tandem_ns::protein::note_optional n=prot.note();
	    std::cerr << "Note: " << n << std::endl;
	    //std::istream << n;
	  }

	  
	  //std::cerr << "Prot: " << p.id() << std::endl;
	  //std::cerr << "Pep: " << peptideObj << std::endl;
	}
	
	BOOST_FOREACH(const tandem_ns::group::group1_type &groupGAML, groupObj.group1())
	{
	  //std::cerr << "GAML: " << groupGAML.label() << std::endl;
	  
	  BOOST_FOREACH(const gaml_tandem_ns::trace &traceGAML, groupGAML.trace())
	  {
	    //std::cerr << "GAML TRACE: " << traceGAML << std::endl;
	    BOOST_FOREACH(const gaml_tandem_ns::attribute &attributeTraceGAML, traceGAML.attribute())
	    {
	      std::cerr << "GAML atr: " << attributeTraceGAML << std::endl;
	    }
	  }
	  
	  //::gaml_tandem_ns::trace traceGAML=groupGAML.trace();
	}
	
      }
      
      //*docGroup.release(); //Remove it and its children
    }
    
    ifs.close();
    
    // XMLString Transcode get text content
  }
  catch (const xml_schema::exception& e)
  {
    cerr << "Problem reading the xml file: " << fn << endl;
    cerr << e << endl;
    exit(1);
  }
  
}

